---
title: "Sistema de Validaci√≥n"
description: "Funcionamiento detallado de los algoritmos de validaci√≥n autom√°tica de cargos de peaje"
---

# Sistema de Validaci√≥n

El sistema de validaci√≥n de Paso R√°pido ejecuta autom√°ticamente 4 tipos de validaci√≥n para detectar fraudes, duplicados y errores en los cargos de peaje. Esta secci√≥n explica en detalle c√≥mo funciona cada validaci√≥n.

## Visi√≥n General del Proceso

<Steps>
<Step title="Activaci√≥n Autom√°tica">
Las validaciones se ejecutan autom√°ticamente cuando:
- Se importan nuevos cargos de peaje
- Se solicita validaci√≥n manual desde la interfaz
- Se ejecuta un proceso programado (cron job)

<Note>
El sistema puede procesar miles de cargos simult√°neamente con alta eficiencia.
</Note>
</Step>

<Step title="Preparaci√≥n de Datos">
Antes de validar, el sistema:
- Sincroniza datos GPS desde ERM Karma API
- Identifica asignaciones de tags vigentes
- Consulta tarifas oficiales de estaciones
- Prepara contexto completo para cada cargo

<Check>
La preparaci√≥n garantiza que las validaciones tengan toda la informaci√≥n necesaria.
</Check>
</Step>

<Step title="Ejecuci√≥n en Paralelo">
Las 4 validaciones se ejecutan simult√°neamente:
- **Validaci√≥n GPS**: Confirma ubicaci√≥n del veh√≠culo
- **Detecci√≥n de Duplicados**: Identifica cargos repetidos
- **Validaci√≥n de Categor√≠a**: Verifica montos correctos
- **Verificaci√≥n de Tags**: Confirma estado activo

<Warning>
El orden de ejecuci√≥n no afecta los resultados, pero todas deben completarse.
</Warning>
</Step>

<Step title="Consolidaci√≥n de Resultados">
El sistema consolida los resultados:
- Asigna estado final a cada cargo
- Genera recomendaciones de acci√≥n
- Documenta evidencia para auditor√≠a
- Actualiza m√©tricas y estad√≠sticas

<Tip>
Los resultados se almacenan permanentemente para an√°lisis hist√≥rico.
</Tip>
</Step>
</Steps>

## 1. Validaci√≥n GPS

### Objetivo
Confirmar que el veh√≠culo asociado al tag realmente estuvo presente en la estaci√≥n de peaje en el momento del cargo.

<img
  src="/images/gps_validation.png"
  alt="Validaci√≥n GPS mostrando ubicaci√≥n del veh√≠culo vs estaci√≥n de peaje"
/>

### Algoritmo Detallado

<Tabs>
<Tab title="Fase 1: B√∫squeda Temporal">
**Objetivo**: Encontrar datos GPS contempor√°neos al cargo

```python
# Pseudoc√≥digo simplificado
def buscar_datos_gps(cargo):
    ventana_inicial = 1  # minuto
    ventana_maxima = 5   # minutos
    
    for ventana in range(ventana_inicial, ventana_maxima + 1):
        inicio = cargo.fecha - timedelta(minutes=ventana)
        fin = cargo.fecha + timedelta(minutes=ventana)
        
        mensajes_gps = consultar_gps(
            car_id=cargo.vehiculo.car_id,
            desde=inicio,
            hasta=fin
        )
        
        if mensajes_gps:
            return mensajes_gps
    
    return None  # Sin telemetr√≠a
```

**Criterios de b√∫squeda**:
- Ventana inicial: ¬±1 minuto del cargo
- Expansi√≥n progresiva hasta ¬±5 minutos
- Filtrado por veh√≠culo espec√≠fico
- Ordenamiento por proximidad temporal
</Tab>

<Tab title="Fase 2: C√°lculo de Distancia">
**Objetivo**: Medir distancia entre posici√≥n GPS y estaci√≥n

```python
def calcular_distancia_haversine(lat1, lon1, lat2, lon2):
    """
    Calcula distancia entre dos puntos GPS usando f√≥rmula haversine
    Resultado en metros con alta precisi√≥n
    """
    R = 6371000  # Radio de la Tierra en metros
    
    lat1_rad = math.radians(lat1)
    lat2_rad = math.radians(lat2)
    delta_lat = math.radians(lat2 - lat1)
    delta_lon = math.radians(lon2 - lon1)
    
    a = (math.sin(delta_lat/2)**2 + 
         math.cos(lat1_rad) * math.cos(lat2_rad) * 
         math.sin(delta_lon/2)**2)
    
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    
    return R * c  # Distancia en metros
```

**Par√°metros configurables**:
- **Umbral de distancia**: 500 metros por defecto
- **Tolerancia urbana**: 200 metros para zonas densas
- **Tolerancia rural**: 1000 metros para √°reas remotas
</Tab>

<Tab title="Fase 3: Validaci√≥n de Coherencia">
**Objetivo**: Verificar que los datos GPS sean l√≥gicamente v√°lidos

**Verificaciones aplicadas**:

<AccordionGroup>
<Accordion title="Velocidad Coherente">
- **Rango normal**: 0-120 km/h
- **Velocidad cero**: V√°lida (veh√≠culo detenido)
- **Velocidad excesiva**: Marca como sospechoso
- **Aceleraci√≥n imposible**: Detecta errores de GPS
</Accordion>

<Accordion title="Secuencia Temporal">
- **Orden cronol√≥gico**: Los timestamps deben ser coherentes
- **Saltos temporales**: Detecta mensajes fuera de secuencia
- **Zona horaria**: Normaliza diferencias de UTC
</Accordion>

<Accordion title="Ubicaci√≥n Geogr√°fica">
- **Coordenadas v√°lidas**: Dentro de rangos terrestres
- **Saltos de ubicaci√≥n**: Detecta teletransporte imposible
- **Coherencia de ruta**: Valida continuidad geogr√°fica
</Accordion>
</AccordionGroup>
</Tab>

<Tab title="Fase 4: Clasificaci√≥n Final">
**Estados resultantes**:

<CardGroup cols={3}>
<Card title="VALIDO" icon="check-circle">
**Criterios cumplidos**:
- Datos GPS disponibles
- Distancia ‚â§ umbral configurado
- Tiempo ‚â§ ventana permitida
- Coherencia verificada

**Acci√≥n**: Aprobar cargo autom√°ticamente
</Card>

<Card title="UBICACION_INVALIDA" icon="x-circle">
**Criterios fallidos**:
- Veh√≠culo muy lejos de estaci√≥n
- Datos GPS inconsistentes
- Evidencia de fraude

**Acci√≥n**: Marcar para revisi√≥n manual
</Card>

<Card title="SIN_TELEMETRIA" icon="question-mark-circle">
**Situaci√≥n**:
- No hay datos GPS disponibles
- Dispositivo desconectado
- Problemas de conectividad

**Acci√≥n**: Evaluar caso por caso
</Card>
</CardGroup>
</Tab>
</Tabs>

### Casos Especiales

<AccordionGroup>
<Accordion title="T√∫neles y Zonas Sin Cobertura">
**Problema**: P√©rdida temporal de se√±al GPS en t√∫neles largos o zonas remotas.

**Soluci√≥n implementada**:
- Extrapolaci√≥n de ruta basada en √∫ltimo punto conocido
- Tolerancia aumentada en zonas identificadas como problem√°ticas
- Validaci√≥n cruzada con cargos anteriores/posteriores del mismo veh√≠culo

**Estaciones afectadas**: T√∫neles urbanos, pasos monta√±osos, zonas rurales remotas
</Accordion>

<Accordion title="Congesti√≥n de Tr√°fico">
**Problema**: Veh√≠culo detenido en cola puede estar lejos de la cabina de cobro.

**Soluci√≥n implementada**:
- Radio de tolerancia expandido en horas pico
- An√°lisis de velocidad promedio en la zona
- Consideraci√≥n de tiempo de espera en cola

**Horarios cr√≠ticos**: 7-9 AM, 12-2 PM, 5-7 PM en d√≠as laborales
</Accordion>

<Accordion title="Estaciones M√∫ltiples Cercanas">
**Problema**: Varias estaciones de peaje muy pr√≥ximas pueden generar ambig√ºedad.

**Soluci√≥n implementada**:
- An√°lisis de direcci√≥n de viaje basado en secuencia GPS
- Correlaci√≥n con cargos anteriores y posteriores
- Validaci√≥n cruzada con datos de tr√°fico

**Ejemplos**: Complejos de peaje con m√∫ltiples cabinas, bifurcaciones de autopistas
</Accordion>
</AccordionGroup>

## 2. Detecci√≥n de Duplicados

### Objetivo
Identificar cargos duplicados que podr√≠an resultar en doble facturaci√≥n por el mismo paso de peaje.

### Algoritmo de Detecci√≥n

<Tabs>
<Tab title="Criterios de Matching">
**Campos principales para identificar duplicados**:

<ParamField path="tag_number" type="INTEGER" required>
N√∫mero del tag - debe ser exactamente igual
</ParamField>

<ParamField path="station_name" type="TEXT" required>
Nombre de la estaci√≥n - debe coincidir exactamente
</ParamField>

<ParamField path="charge_date" type="TIMESTAMP" required>
Fecha y hora del cargo - tolerancia de ¬±10 minutos
</ParamField>

<ParamField path="amount" type="DECIMAL">
Monto cobrado - tolerancia de ¬±5% o ¬±$500 (lo que sea menor)
</ParamField>

**Algoritmo de scoring**:
```python
def calcular_score_duplicado(cargo1, cargo2):
    score = 0
    
    # Tag exacto (+40 puntos)
    if cargo1.tag == cargo2.tag:
        score += 40
    
    # Estaci√≥n exacta (+30 puntos)
    if cargo1.station == cargo2.station:
        score += 30
    
    # Tiempo similar (+20 puntos)
    diff_minutos = abs((cargo1.fecha - cargo2.fecha).total_seconds() / 60)
    if diff_minutos <= 10:
        score += 20 * (1 - diff_minutos/10)  # Score decreciente
    
    # Monto similar (+10 puntos)
    diff_monto = abs(cargo1.amount - cargo2.amount)
    if diff_monto <= max(500, cargo1.amount * 0.05):
        score += 10 * (1 - diff_monto/max(500, cargo1.amount * 0.05))
    
    return score

# Umbral de duplicado: 70 puntos o m√°s
```
</Tab>

<Tab title="Tipos de Duplicados">
### Duplicado Exacto
**Caracter√≠sticas**:
- Todos los campos principales id√©nticos
- Diferencia de tiempo < 2 minutos
- Mismo monto exacto

**Causa com√∫n**: Error en el sistema de facturaci√≥n de la concesionaria

**Acci√≥n recomendada**: Eliminar uno de los cargos autom√°ticamente

### Duplicado Parcial
**Caracter√≠sticas**:
- Tag y estaci√≥n iguales
- Tiempo similar (2-10 minutos)
- Monto ligeramente diferente

**Causa com√∫n**: Correcci√≥n o ajuste manual por parte de la concesionaria

**Acci√≥n recomendada**: Revisi√≥n manual para determinar cu√°l mantener

### Duplicado Sospechoso
**Caracter√≠sticas**:
- Tag y estaci√≥n iguales
- Tiempo similar pero monto muy diferente
- Posible cambio de categor√≠a

**Causa com√∫n**: Error en clasificaci√≥n de veh√≠culo o fraude

**Acci√≥n recomendada**: Investigaci√≥n detallada con validaci√≥n GPS
</Tab>

<Tab title="Resoluci√≥n de Duplicados">
### Proceso Autom√°tico

<Steps>
<Step title="Identificaci√≥n">
El sistema detecta potenciales duplicados usando el algoritmo de scoring.

**Criterios autom√°ticos**:
- Score ‚â• 90: Duplicado exacto
- Score 70-89: Duplicado probable
- Score 50-69: Sospechoso, requiere revisi√≥n
</Step>

<Step title="An√°lisis de Contexto">
Para cada par de duplicados detectados:

```python
def analizar_contexto_duplicado(cargo1, cargo2):
    contexto = {
        'diferencia_tiempo': abs(cargo1.fecha - cargo2.fecha),
        'diferencia_monto': abs(cargo1.amount - cargo2.amount),
        'validacion_gps_cargo1': cargo1.validation_status,
        'validacion_gps_cargo2': cargo2.validation_status,
        'secuencia_temporal': determinar_orden_cronologico(cargo1, cargo2)
    }
    return contexto
```
</Step>

<Step title="Decisi√≥n Autom√°tica">
**Reglas de resoluci√≥n autom√°tica**:

<AccordionGroup>
<Accordion title="Mantener el Primero">
- Cuando ambos tienen validaci√≥n GPS exitosa
- Diferencia de tiempo < 5 minutos
- Montos id√©nticos o muy similares
</Accordion>

<Accordion title="Mantener el V√°lido">
- Un cargo tiene validaci√≥n GPS exitosa, el otro no
- Se mantiene el que tiene evidencia GPS
</Accordion>

<Accordion title="Marcar para Revisi√≥n">
- Ambos tienen validaci√≥n GPS exitosa pero en ubicaciones diferentes
- Diferencia significativa en montos
- Patrones sospechosos de uso del tag
</Accordion>
</AccordionGroup>
</Step>
</Steps>

### Proceso Manual

Para casos que requieren intervenci√≥n humana:

<CardGroup cols={2}>
<Card title="Herramientas Disponibles" icon="tools">
**Informaci√≥n presentada al analista**:
- Cronolog√≠a completa de ambos cargos
- Mapas GPS con ubicaciones exactas
- Historial reciente del tag
- Comparaci√≥n lado a lado de detalles
- Recomendaci√≥n del algoritmo autom√°tico
</Card>

<Card title="Opciones de Resoluci√≥n" icon="check-square">
**Decisiones posibles**:
- **Mantener ambos**: Si se determina que son leg√≠timos
- **Eliminar duplicado**: Marcar uno como duplicado
- **Investigar m√°s**: Solicitar informaci√≥n adicional
- **Reportar fraude**: Escalar a investigaci√≥n de seguridad
</Card>
</CardGroup>
</Tab>
</Tabs>

### Patrones de Fraude Detectados

<Warning>
La detecci√≥n de duplicados tambi√©n identifica patrones sospechosos que pueden indicar fraude sistem√°tico.
</Warning>

<AccordionGroup>
<Accordion title="Uso Simult√°neo de Tag">
**Patr√≥n**: El mismo tag genera cargos en estaciones distantes en tiempos imposibles de recorrer.

**Ejemplo**: Tag #123456 cobra en "Peaje Norte Km 45" a las 14:30 y en "Peaje Sur Km 80" a las 14:35.

**Implicaci√≥n**: Posible clonaci√≥n del tag o error en el sistema.

**Acci√≥n**: Inhabilitaci√≥n temporal del tag e investigaci√≥n.
</Accordion>

<Accordion title="Frecuencia Anormal">
**Patr√≥n**: Un tag genera cargos muy frecuentes en la misma estaci√≥n.

**Ejemplo**: 15 cargos en la misma estaci√≥n en un d√≠a (normal: 2-4 m√°ximo).

**Implicaci√≥n**: Posible mal funcionamiento del tag o fraude.

**Acci√≥n**: An√°lisis de ruta GPS para confirmar legitimidad.
</Accordion>

<Accordion title="Montos Inconsistentes">
**Patr√≥n**: El mismo tag genera cargos con montos muy variables en la misma estaci√≥n.

**Ejemplo**: Alternancia entre categor√≠a 1 ($5,000) y categor√≠a 4 ($16,000) sin justificaci√≥n.

**Implicaci√≥n**: Posible manipulaci√≥n manual o error sistem√°tico.

**Acci√≥n**: Revisi√≥n de asignaciones de categor√≠a del veh√≠culo.
</Accordion>
</AccordionGroup>

## 3. Validaci√≥n de Categor√≠a

### Objetivo
Verificar que el monto cobrado corresponde a la categor√≠a correcta del veh√≠culo seg√∫n las tarifas oficiales.

<img
  src="/images/category_validation.png"
  alt="An√°lisis de validaci√≥n de categor√≠as y montos"
/>

### Proceso de Validaci√≥n

<Tabs>
<Tab title="Determinaci√≥n de Categor√≠a">
**Paso 1**: Identificar el veh√≠culo asociado al cargo

```python
def obtener_vehiculo_por_tag(tag_number, fecha_cargo, org_id):
    # Buscar asignaci√≥n vigente en la fecha del cargo
    asignacion = db.query("""
        SELECT car_id, category 
        FROM tag_assignments 
        WHERE tag_number = %s 
        AND org_id = %s
        AND date <= %s 
        AND (expires_at IS NULL OR expires_at >= %s)
        AND status = 'Valido'
        ORDER BY date DESC 
        LIMIT 1
    """, [tag_number, org_id, fecha_cargo, fecha_cargo])
    
    if not asignacion:
        return None, "Tag sin asignaci√≥n v√°lida"
    
    vehiculo = db.get_car(asignacion.car_id)
    return vehiculo, asignacion.category
```

**Paso 2**: Determinar categor√≠a esperada

<CardGroup cols={5}>
<Card title="Categor√≠a 1" icon="car">
**Veh√≠culos**:
- Autom√≥vil
- Motocicleta
- SUV peque√±o

**Identificaci√≥n**:
- `car_type`: "Autom√≥vil", "Motocicleta"
- `sub_type`: "Sed√°n", "Hatchback"
</Card>

<Card title="Categor√≠a 2" icon="truck">
**Veh√≠culos**:
- Camioneta
- SUV grande
- Furgoneta

**Identificaci√≥n**:
- `car_type`: "Camioneta"
- `sub_type`: "Pickup", "SUV"
</Card>

<Card title="Categor√≠a 3" icon="bus">
**Veh√≠culos**:
- Bus
- Cami√≥n 2 ejes
- Furg√≥n grande

**Identificaci√≥n**:
- `car_type`: "Bus", "Cami√≥n"
- Ejes: 2
</Card>

<Card title="Categor√≠a 4" icon="truck">
**Veh√≠culos**:
- Cami√≥n 3+ ejes
- Tractomula sencilla

**Identificaci√≥n**:
- `car_type`: "Cami√≥n"
- Ejes: 3 o m√°s
</Card>

<Card title="Categor√≠a 5" icon="truck">
**Veh√≠culos**:
- Tractomula + remolque
- Veh√≠culos especiales

**Identificaci√≥n**:
- `car_type`: "Tractomula"
- `sub_type`: "Con remolque"
</Card>
</CardGroup>
</Tab>

<Tab title="Consulta de Tarifas">
**Paso 3**: Obtener tarifa oficial de la estaci√≥n

```python
def obtener_tarifa_oficial(station_name, category):
    tarifa = db.query("""
        SELECT category_1, category_2, category_3, category_4, category_5
        FROM tolls 
        WHERE name = %s
    """, [station_name]).first()
    
    if not tarifa:
        return None, "Estaci√≥n no encontrada en cat√°logo"
    
    # Mapear categor√≠a a campo correspondiente
    tarifas_por_categoria = {
        1: tarifa.category_1,
        2: tarifa.category_2,
        3: tarifa.category_3,
        4: tarifa.category_4,
        5: tarifa.category_5
    }
    
    return tarifas_por_categoria.get(category), None
```

**Manejo de estaciones desconocidas**:
- Se registra como "Estaci√≥n Desconocida"
- Se solicita configuraci√≥n manual de tarifas
- Se marca el cargo para revisi√≥n
- Se notifica al administrador para actualizar cat√°logo
</Tab>

<Tab title="Comparaci√≥n y Clasificaci√≥n">
**Paso 4**: Comparar monto cobrado vs. esperado

```python
def validar_categoria(cargo, tarifa_esperada):
    diferencia = cargo.amount - tarifa_esperada
    porcentaje_diferencia = (diferencia / tarifa_esperada) * 100
    
    # Tolerancia para variaciones menores (promociones, descuentos)
    tolerancia_pesos = 500  # ¬±$500
    tolerancia_porcentaje = 5  # ¬±5%
    
    if abs(diferencia) <= tolerancia_pesos or abs(porcentaje_diferencia) <= tolerancia_porcentaje:
        return {
            'status': 'CORRECTO',
            'diferencia': diferencia,
            'porcentaje': porcentaje_diferencia,
            'accion': 'Ninguna - Cargo v√°lido'
        }
    elif diferencia > 0:
        return {
            'status': 'COBRO_MAYOR',
            'diferencia': diferencia,
            'porcentaje': porcentaje_diferencia,
            'accion': 'Solicitar reembolso',
            'impacto': 'P√©rdida econ√≥mica',
            'prioridad': 'Alta'
        }
    else:
        return {
            'status': 'COBRO_MENOR',
            'diferencia': abs(diferencia),
            'porcentaje': abs(porcentaje_diferencia),
            'accion': 'Aceptar (favorable)',
            'impacto': 'Ahorro accidental',
            'prioridad': 'Baja'
        }
```

**Estados resultantes**:

<Tabs>
<Tab title="Correcto">
**Criterio**: Monto cobrado = Tarifa esperada (¬±tolerancia)

**Indicador**: ‚úÖ Verde

**Acci√≥n**: Ninguna, cargo aprobado autom√°ticamente
</Tab>

<Tab title="Cobro Mayor">
**Criterio**: Monto cobrado > Tarifa esperada + tolerancia

**Indicador**: ‚ùå Rojo

**Acciones recomendadas**:
- Solicitar reembolso a la concesionaria
- Documentar para reclamo formal
- Incluir en reporte de p√©rdidas
</Tab>

<Tab title="Cobro Menor">
**Criterio**: Monto cobrado < Tarifa esperada - tolerancia

**Indicador**: ‚ö†Ô∏è Amarillo

**Acciones recomendadas**:
- Aceptar (favorable para la empresa)
- Documentar como ahorro
- Monitorear si es patr√≥n recurrente
</Tab>
</Tabs>
</Tab>
</Tabs>

### Casos Especiales de Categor√≠a

<AccordionGroup>
<Accordion title="Promociones y Descuentos">
**Situaci√≥n**: Concesionarias aplican descuentos temporales o promociones especiales.

**Detecci√≥n**: M√∫ltiples veh√≠culos de la misma categor√≠a cobrados con monto menor en fechas espec√≠ficas.

**Manejo**:
- Se marca como "Cobro Menor" inicialmente
- Sistema aprende patrones de promociones
- Administrador puede configurar per√≠odos de promoci√≥n conocidos
- Se ajustan tolerancias autom√°ticamente durante promociones
</Accordion>

<Accordion title="Veh√≠culos H√≠bridos o Especiales">
**Situaci√≥n**: Veh√≠culos que no encajan perfectamente en las 5 categor√≠as est√°ndar.

**Ejemplos**: 
- Buses articulados (¬øcategor√≠a 3 o 4?)
- Camiones con equipos especiales
- Veh√≠culos de emergencia

**Manejo**:
- Asignaci√≥n manual de categor√≠a por parte del administrador
- Documentaci√≥n de la decisi√≥n para casos similares
- Creaci√≥n de reglas espec√≠ficas para tipos especiales
</Accordion>

<Accordion title="Cambios de Categor√≠a Temporal">
**Situaci√≥n**: Un veh√≠culo cambia temporalmente de categor√≠a (ej: cami√≥n descargado vs. cargado).

**Detecci√≥n**: El mismo veh√≠culo genera cargos con diferentes categor√≠as en per√≠odos cortos.

**Manejo**:
- An√°lisis de patrones temporales
- Validaci√≥n cruzada con datos de peso (si disponibles)
- Configuraci√≥n de categor√≠as variables para veh√≠culos espec√≠ficos
</Accordion>
</AccordionGroup>

## 4. Verificaci√≥n de Estado de Tags

### Objetivo
Confirmar que el tag utilizado estaba en estado "V√°lido" en el momento del cargo, detectando uso de tags inhabilitados.

### Algoritmo de Verificaci√≥n

<Tabs>
<Tab title="Consulta de Estado Hist√≥rico">
**Proceso**: Determinar el estado del tag en la fecha espec√≠fica del cargo

```python
def verificar_estado_tag(tag_number, fecha_cargo, org_id):
    # Buscar el estado del tag en la fecha del cargo
    estado_historico = db.query("""
        SELECT status, date, expires_at, car_id
        FROM tag_assignments 
        WHERE tag_number = %s 
        AND org_id = %s
        AND date <= %s
        ORDER BY date DESC, updated_at DESC
        LIMIT 1
    """, [tag_number, org_id, fecha_cargo])
    
    if not estado_historico:
        return {
            'status': 'TAG_NO_ENCONTRADO',
            'detalle': 'No existe asignaci√≥n para este tag',
            'accion': 'Verificar n√∫mero de tag'
        }
    
    # Verificar si el tag hab√≠a expirado
    if estado_historico.expires_at and estado_historico.expires_at < fecha_cargo:
        return {
            'status': 'TAG_EXPIRADO',
            'detalle': f'Tag expir√≥ el {estado_historico.expires_at}',
            'accion': 'Verificar renovaci√≥n'
        }
    
    # Verificar estado en la fecha
    if estado_historico.status == 'Valido':
        return {
            'status': 'VALIDO',
            'detalle': 'Tag estaba activo',
            'accion': 'Ninguna'
        }
    else:
        return {
            'status': 'INHABILITADO',
            'detalle': f'Tag inhabilitado desde {estado_historico.date}',
            'accion': 'Investigar uso no autorizado'
        }
```
</Tab>

<Tab title="Detecci√≥n de Patrones Sospechosos">
### Uso Posterior a Inhabilitaci√≥n

**Algoritmo de detecci√≥n**:
```python
def detectar_uso_post_inhabilitacion(tag_number, org_id):
    # Obtener fecha de inhabilitaci√≥n
    inhabilitacion = db.query("""
        SELECT date, updated_at
        FROM tag_assignments 
        WHERE tag_number = %s 
        AND org_id = %s
        AND status = 'Inhabilitado'
        ORDER BY updated_at DESC
        LIMIT 1
    """, [tag_number, org_id])
    
    if not inhabilitacion:
        return []
    
    # Buscar cargos posteriores a la inhabilitaci√≥n
    cargos_sospechosos = db.query("""
        SELECT id, date, station, amount
        FROM toll_charges
        WHERE tag = %s 
        AND org_id = %s
        AND date > %s
        ORDER BY date DESC
    """, [tag_number, org_id, inhabilitacion.date])
    
    return cargos_sospechosos
```

### Frecuencia Anormal de Inhabilitaci√≥n

**Detecci√≥n**: Tags que se inhabilitan y rehabilitan frecuentemente
```python
def detectar_patron_inhabilitacion(tag_number, org_id, periodo_dias=90):
    cambios_estado = db.query("""
        SELECT status, date, updated_at
        FROM tag_assignments 
        WHERE tag_number = %s 
        AND org_id = %s
        AND date >= %s
        ORDER BY updated_at ASC
    """, [tag_number, org_id, datetime.now() - timedelta(days=periodo_dias)])
    
    # Contar cambios de estado
    cambios = 0
    estado_anterior = None
    
    for registro in cambios_estado:
        if estado_anterior and estado_anterior != registro.status:
            cambios += 1
        estado_anterior = registro.status
    
    # M√°s de 3 cambios en 90 d√≠as es sospechoso
    return cambios > 3
```
</Tab>

<Tab title="Validaci√≥n Cruzada">
### Correlaci√≥n con Datos GPS

Cuando un tag inhabilitado genera cargos, se valida si hay evidencia GPS:

<Steps>
<Step title="Verificar Presencia GPS">
Si hay datos GPS que confirman la presencia del veh√≠culo asignado:
- **Conclusi√≥n**: Posible error en fecha de inhabilitaci√≥n
- **Acci√≥n**: Revisar historial de inhabilitaci√≥n
- **Prioridad**: Media
</Step>

<Step title="Sin Datos GPS">
Si no hay datos GPS del veh√≠culo asignado:
- **Conclusi√≥n**: Posible uso fraudulento del tag
- **Acci√≥n**: Investigaci√≥n de seguridad
- **Prioridad**: Alta
</Step>

<Step title="GPS de Veh√≠culo Diferente">
Si hay datos GPS pero de un veh√≠culo diferente al asignado:
- **Conclusi√≥n**: Probable clonaci√≥n o transferencia no autorizada
- **Acci√≥n**: Inhabilitaci√≥n inmediata y investigaci√≥n
- **Prioridad**: Cr√≠tica
</Step>
</Steps>

### An√°lisis de Impacto Financiero

```python
def calcular_impacto_tag_inhabilitado(tag_number, org_id):
    cargos_post_inhabilitacion = obtener_cargos_sospechosos(tag_number, org_id)
    
    impacto = {
        'total_cargos': len(cargos_post_inhabilitacion),
        'monto_total': sum(cargo.amount for cargo in cargos_post_inhabilitacion),
        'periodo': calcular_periodo(cargos_post_inhabilitacion),
        'estaciones_afectadas': len(set(cargo.station for cargo in cargos_post_inhabilitacion))
    }
    
    return impacto
```
</Tab>
</Tabs>

### Estados de Validaci√≥n de Tags

<CardGroup cols={3}>
<Card title="V√°lido" icon="check-circle">
**Descripci√≥n**: Tag estaba activo en la fecha del cargo

**Criterios**:
- Estado = "Valido" en fecha del cargo
- No hab√≠a expirado
- Asignaci√≥n vigente

**Indicador**: üü¢ Verde

**Acci√≥n**: Ninguna
</Card>

<Card title="Inhabilitado" icon="x-circle">
**Descripci√≥n**: Tag estaba desactivado cuando se gener√≥ el cargo

**Criterios**:
- Estado = "Inhabilitado" antes de la fecha del cargo
- Uso posterior a inhabilitaci√≥n confirmada

**Indicador**: üî¥ Rojo

**Acci√≥n**: Investigar fraude potencial
</Card>

<Card title="No Encontrado" icon="question-mark-circle">
**Descripci√≥n**: No existe registro del tag en el sistema

**Criterios**:
- Tag nunca fue asignado
- N√∫mero de tag incorrecto
- Datos de importaci√≥n incompletos

**Indicador**: ‚ö™ Gris

**Acci√≥n**: Verificar datos de importaci√≥n
</Card>
</CardGroup>

## Consolidaci√≥n de Resultados

### Algoritmo de Clasificaci√≥n Final

Una vez completadas las 4 validaciones, el sistema consolida los resultados:

```python
def clasificar_cargo_final(cargo, resultados_validaciones):
    """
    Determina el estado final del cargo basado en todas las validaciones
    """
    gps = resultados_validaciones['gps']
    duplicado = resultados_validaciones['duplicado']
    categoria = resultados_validaciones['categoria']
    tag = resultados_validaciones['tag']
    
    # Clasificaci√≥n por prioridad de severidad
    if tag['status'] == 'INHABILITADO':
        return {
            'estado_final': 'FRAUDULENTO',
            'prioridad': 'CRITICA',
            'razon_principal': 'Tag inhabilitado',
            'accion_recomendada': 'Rechazar cargo e investigar'
        }
    
    if duplicado['is_duplicate']:
        return {
            'estado_final': 'DUPLICADO',
            'prioridad': 'ALTA',
            'razon_principal': 'Cargo duplicado detectado',
            'accion_recomendada': 'Eliminar duplicado'
        }
    
    if gps['status'] == 'UBICACION_INVALIDA':
        return {
            'estado_final': 'GPS_INVALIDO',
            'prioridad': 'ALTA',
            'razon_principal': 'Veh√≠culo no estaba en la ubicaci√≥n',
            'accion_recomendada': 'Rechazar cargo'
        }
    
    if categoria['status'] == 'COBRO_MAYOR':
        return {
            'estado_final': 'SOBRECARGO',
            'prioridad': 'MEDIA',
            'razon_principal': f'Cobro excesivo por ${categoria["diferencia"]}',
            'accion_recomendada': 'Solicitar reembolso'
        }
    
    if gps['status'] == 'SIN_TELEMETRIA':
        return {
            'estado_final': 'SIN_VALIDAR_GPS',
            'prioridad': 'BAJA',
            'razon_principal': 'No hay datos GPS para validar',
            'accion_recomendada': 'Aceptar condicionalmente'
        }
    
    # Si todas las validaciones pasan
    return {
        'estado_final': 'VALIDO',
        'prioridad': 'NINGUNA',
        'razon_principal': 'Todas las validaciones exitosas',
        'accion_recomendada': 'Aprobar cargo'
    }
```

### M√©tricas y Estad√≠sticas

El sistema genera m√©tricas autom√°ticas para monitoreo:

<Tabs>
<Tab title="M√©tricas de Validaci√≥n">
**Por tipo de validaci√≥n**:
- **GPS**: % de cargos con ubicaci√≥n v√°lida
- **Duplicados**: N√∫mero de duplicados detectados por per√≠odo
- **Categor√≠a**: % de cargos con monto correcto
- **Tags**: % de tags v√°lidos vs. inhabilitados

**Tendencias temporales**:
- Evoluci√≥n de tasas de fraude por mes
- Patrones estacionales de errores
- Efectividad de las validaciones implementadas
</Tab>

<Tab title="Impacto Financiero">
**Ahorros detectados**:
- Monto total de duplicados evitados
- Sobrecargos identificados para reembolso
- Fraudes detectados y su valor

**Costos evitados**:
- Proyecci√≥n de p√©rdidas sin el sistema
- ROI del sistema de validaci√≥n
- Tiempo ahorrado en revisiones manuales
</Tab>

<Tab title="Calidad de Datos">
**Cobertura GPS**:
- % de cargos con datos GPS disponibles
- Calidad promedio de se√±al GPS
- Zonas problem√°ticas identificadas

**Completitud de datos**:
- % de tags con asignaciones v√°lidas
- Estaciones con tarifas configuradas
- Veh√≠culos con categor√≠as definidas
</Tab>
</Tabs>

## Configuraci√≥n y Personalizaci√≥n

### Par√°metros Configurables

<AccordionGroup>
<Accordion title="Validaci√≥n GPS">
<ParamField body="time_window_minutes" type="integer" default="1">
Ventana de tiempo inicial para buscar datos GPS (¬±minutos)
</ParamField>

<ParamField body="max_time_window_minutes" type="integer" default="5">
Ventana m√°xima de tiempo si no se encuentran datos inicialmente
</ParamField>

<ParamField body="distance_threshold_meters" type="integer" default="500">
Distancia m√°xima permitida entre veh√≠culo y estaci√≥n
</ParamField>

<ParamField body="urban_distance_threshold" type="integer" default="200">
Distancia reducida para zonas urbanas densas
</ParamField>

<ParamField body="rural_distance_threshold" type="integer" default="1000">
Distancia aumentada para zonas rurales
</ParamField>
</Accordion>

<Accordion title="Detecci√≥n de Duplicados">
<ParamField body="duplicate_time_threshold_minutes" type="integer" default="10">
Tiempo m√°ximo entre cargos para considerarlos duplicados
</ParamField>

<ParamField body="amount_tolerance_percentage" type="decimal" default="5.0">
Tolerancia porcentual para diferencias en montos
</ParamField>

<ParamField body="amount_tolerance_absolute" type="integer" default="500">
Tolerancia absoluta en pesos para diferencias en montos
</ParamField>

<ParamField body="duplicate_score_threshold" type="integer" default="70">
Score m√≠nimo para considerar un cargo como duplicado
</ParamField>
</Accordion>

<Accordion title="Validaci√≥n de Categor√≠a">
<ParamField body="category_tolerance_percentage" type="decimal" default="5.0">
Tolerancia porcentual para variaciones de tarifa
</ParamField>

<ParamField body="category_tolerance_absolute" type="integer" default="500">
Tolerancia absoluta para variaciones de tarifa
</ParamField>

<ParamField body="promotion_detection_enabled" type="boolean" default="true">
Habilitar detecci√≥n autom√°tica de promociones
</ParamField>
</Accordion>

<Accordion title="Verificaci√≥n de Tags">
<ParamField body="tag_expiration_grace_days" type="integer" default="7">
D√≠as de gracia despu√©s de expiraci√≥n antes de marcar como inv√°lido
</ParamField>

<ParamField body="frequent_status_change_threshold" type="integer" default="3">
N√∫mero m√°ximo de cambios de estado en 90 d√≠as
</ParamField>
</Accordion>
</AccordionGroup>

### Personalizaci√≥n por Organizaci√≥n

Cada organizaci√≥n puede tener configuraciones espec√≠ficas:

<Tabs>
<Tab title="Perfiles de Validaci√≥n">
**Perfil Estricto**:
- Tolerancias m√≠nimas
- Validaci√≥n GPS obligatoria
- Revisi√≥n manual de todos los casos sospechosos

**Perfil Balanceado** (por defecto):
- Tolerancias moderadas
- Automatizaci√≥n inteligente
- Revisi√≥n manual solo de casos cr√≠ticos

**Perfil Permisivo**:
- Tolerancias amplias
- M√°xima automatizaci√≥n
- M√≠nima intervenci√≥n manual
</Tab>

<Tab title="Reglas Espec√≠ficas">
**Por tipo de veh√≠culo**:
- Tolerancias diferentes para cada categor√≠a
- Validaciones especiales para veh√≠culos cr√≠ticos
- Excepciones para equipos especiales

**Por ruta o estaci√≥n**:
- Configuraciones espec√≠ficas para estaciones problem√°ticas
- Ajustes para rutas con cobertura GPS limitada
- Tolerancias especiales para t√∫neles o zonas remotas

**Por horario**:
- Tolerancias diferentes para horas pico
- Validaciones especiales para horarios nocturnos
- Ajustes para d√≠as festivos o fines de semana
</Tab>
</Tabs>

## Pr√≥ximos Pasos

<CardGroup cols={2}>
<Card title="Gu√≠a del Usuario" icon="user" href="/guia-usuario">
Aprende a operar el sistema d√≠a a d√≠a y revisar validaciones
</Card>
<Card title="Flujos de Trabajo" icon="workflow" href="/flujos-trabajo">
Procesos completos desde importaci√≥n hasta reportes finales
</Card>
</CardGroup> 